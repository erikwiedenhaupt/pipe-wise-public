# api/routes_tools.py
"""
Pipewise API â€“ Tool registry & autogen (scaffold)
"""

from __future__ import annotations

import uuid
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel, Field

from core.models import ToolSpec  # type: ignore

router = APIRouter(tags=["tools"], prefix="")

# In-memory store for autogen proposals awaiting accept
_AUTOGEN_DRAFTS: Dict[str, Dict[str, Any]] = {}


@router.get("/tools", summary="List tools")
def list_tools(request: Request) -> List[Dict[str, Any]]:
    registry = request.app.state.tools
    return [t.dict() for t in registry.list()]


class ToolRegisterBody(BaseModel):
    name: str
    signature: Dict[str, Any] = Field(default_factory=dict)
    code: str
    tests: Optional[str] = None
    description: Optional[str] = None
    version: Optional[str] = "0.0.1"


class ToolRegisterRes(BaseModel):
    tool_id: str
    status: str


@router.post("/tools/register", response_model=ToolRegisterRes, summary="Register a tool")
def register_tool(body: ToolRegisterBody, request: Request) -> ToolRegisterRes:
    registry = request.app.state.tools
    tid = str(uuid.uuid4())
    spec = ToolSpec(
        id=tid,
        name=body.name,
        description=body.description or "registered tool",
        version=body.version,
        input_schema={"signature": body.signature, "code": body.code, "tests": body.tests},
        output_schema={},
        safe_to_run=True,
    )
    registry.register(spec, persist=True)
    return ToolRegisterRes(tool_id=tid, status="registered")


class ToolAutogenReq(BaseModel):
    capability: str
    spec: Optional[Dict[str, Any]] = None
    examples: Optional[List[str]] = None


class ToolAutogenRes(BaseModel):
    proposal: Dict[str, Any]
    review_token: str


@router.post("/tools/autogen", response_model=ToolAutogenRes, summary="Propose autogenerated tool")
def tools_autogen(body: ToolAutogenReq) -> ToolAutogenRes:
    review_token = str(uuid.uuid4())
    name = (body.capability.strip().lower().replace(" ", "_") or "auto_tool")[:40]
    proposal = {
        "name": name,
        "signature": body.spec or {"input": {"type": "string"}},
        "code": "# TODO: autogenerated tool code\n\ndef run(input: str):\n    return input\n",
        "tests": "def test_run():\n    assert run('x') == 'x'\n",
    }
    _AUTOGEN_DRAFTS[review_token] = proposal
    return ToolAutogenRes(proposal=proposal, review_token=review_token)


class ToolAutogenAcceptReq(BaseModel):
    review_token: str


class ToolAutogenAcceptRes(BaseModel):
    tool_id: str
    status: str


@router.post("/tools/autogen/accept", response_model=ToolAutogenAcceptRes, summary="Accept autogenerated tool")
def tools_autogen_accept(body: ToolAutogenAcceptReq, request: Request) -> ToolAutogenAcceptRes:
    registry = request.app.state.tools
    proposal = _AUTOGEN_DRAFTS.pop(body.review_token, None)
    if not proposal:
        raise HTTPException(status_code=404, detail="review_token not found")
    tid = str(uuid.uuid4())
    spec = ToolSpec(
        id=tid,
        name=proposal["name"],
        description="autogenerated tool",
        version="0.0.1",
        input_schema={
            "signature": proposal.get("signature", {}),
            "code": proposal.get("code", ""),
            "tests": proposal.get("tests", ""),
        },
        output_schema={},
        safe_to_run=True,
    )
    registry.register(spec, persist=True)
    return ToolAutogenAcceptRes(tool_id=tid, status="registered")